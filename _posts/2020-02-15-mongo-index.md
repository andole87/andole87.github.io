---
title: "MongoDB 인덱스"
category: "ETC"
---

몽고DB는 스키마 프리로 알려져 있다. 컬렉션에는 맞는 이야기이지만 인덱스에서는 틀린 이야기다.  
몽고DB는 인덱스 구성을 위해 내부적으로 별도 스키마를 가지고 있다. 인덱스 종류, 필드가 어떤 것인지에 대한 메타 정보를 갖고 있으며 스스로 관리한다.  
많은 DBMS가 인덱스를 B-Tree로 구성한다. PK의 경우 리프노드에 디스크 주소를 저장하는 방식을 많이 쓴다. 몽고DB는 B-Tree를 사용하지만 디스크 주소가 아닌 논리 주소를 사용한다.  

## 클러스터 인덱스

몽고DB는 클러스터 인덱스를 지원하지 않는다.

클러스터 인덱스는 정렬 순서대로 실제 데이터를 저장한다. 디스크에 순서대로 저장하므로 범위 검색시 해당 영역을 바로 읽을 수 있다. 즉, 랜덤 IO이 아닌 순차 IO를 수행하므로 속도가 훨씬 빠르다.  

디스크에 레코드나 도큐먼트를 실제 순서대로 저장하려면, 저장하려는 데이터가 정적으로 구조화되어 있어야 한다. 형식이 정해져 있어야 DBMS입장에서 클러스터링, 무결성을 보장할 수 있다.

예를들어 디스크에 4byte의 정수 데이터를 순차적으로 저장한다고 생각해보자. 정수는 모두 4byte이므로 마치 배열처럼 디스크 공간을 할당하고 해당 공간 내의 데이터만 관리해주면 될 것이다. 그러나 중간의 정수 형식을 8byte long으로 바꾼다면 한칸씩 밀려야 할 것이다. 또 4byte씩 읽으려고 할 것이므로 나머지 4byte를 제대로 불러올 수 없다. 즉 제대로 클러스터링 할 수 없다. 때문에 클러스터 인덱스를 지원하는 RDB에서는 필드의 타입을 반드시 정해야 하고 그 자체로 제약조건이 된다.  

몽고DB에 도큐먼트를 추가할 때는 거의 아무런 제약이 없다. 타입이 달라도 되고 필드가 맞지 않아도 된다. 구조화되어 있지 않으므로 근본적으로 클러스터 인덱스를 사용하기 어렵다.  

몽고DB 3.2 전에는 유사 클러스터 인덱스를 사용할 수 있었으나 이후에는 클러스터 인덱스를 사용할 수 없게 되었다. 스토리지 엔진이 변경되었기 때문이다.  

## 몽고DB 스토리지 엔진

### MMAPv1

몽고DB 3.2 이전에 기본으로 사용하던 스토리지 엔진이다. 도큐먼트 아이디를 `DiskLoc` 필드로 저장한다. Offset방식의 64비트 정수 형식이다. 이 값은 도큐먼트가 저장된 디스크의 물리 주소(RowId)를 의미한다. 그래서 직접 접근할 때는 디스크에 바로 접근할 수 있다. 그러나 도큐먼트의 위치가 변경되면 인덱스 트리를 다시 구성해야 하는 문제가 있다.  

예를 들어, 도큐먼트의 크기가 변경(커지면)되면 기존 물리 공간이 넘치게 된다. MMAPv1은 이 때 디스크의 다른 빈 공간에 도큐먼트를 할당하고 물리 주소를 변경한다. 물리 주소가 변경되면 전체 인덱스 트리도 다시 구성해야 한다. 또 대상 도큐먼트를 이동해야 하기 때문에, UPDATE 커맨드의 효율이 매우 떨어진다.  

MMAPv1은 나름대로 `PaddingFactor` 변수를 도입하여 도큐먼트 사이에 일정영역을 비워 놓는 방식을 도입했다. 도큐먼트가 `PaddingFactor` 범위 내에서 크기가 바뀐다면 옮기지 않아도 된다. 그러나 디스크 사용 효율성, 유연한 확장 등에는 근본적인 문제가 있다.

## WiredTiger

몽고DB 3.2 이후 기본으로 쓰이는 스토리지 엔진이다. 역시 도큐먼트 아이디를 `DiskLoc` 필드로 저장한다. 여기서 `DiskLoc` 은 물리 주소가 아닌 논리 주소다. 때문에 MMAPv1과는 다르게 도큐먼트가 변경되어도 주소가 바뀌지 않는다. 대신에, 논리 주소를 물리 주소로 변환하는 내부 인덱스가 있다. 즉 클러스터링되어 있지 않으며, 내부 인덱스 역시 B-Tree 기반으로 구성되어 있다. `WiredTiger`는 UPDATE시 무거운 작업을 할 필요가 없는 대신, 도큐먼트 주소를 바로 접근할 수 없다. PK로 도큐먼트 데이터를 불러올 때, 인덱스 스캔을 두번 수행해야 한다. (PK 스캔, DiskLoc 스캔)

> 도큐먼트의 DiskLoc 확인
>
> `db.collection.find()._addSpecial({ "$showDiskLoc": true })`

## 로컬 인덱스

몽고DB는 샤드 환경을 쉽게 구성할 수 있다. 샤드 클러스터에서 샤드키를 제외한 인덱스는 각 샤드에서만 유효하다. 즉 샤드1에서 1-100, 샤드2에서 101-200 범위의 도큐먼트를 저장하고 있다면, 샤드1에서 1-100에 대한 인덱스를 구성하고 샤드2에서 101-200에 대한 인덱스를 구성한다.

몽고DB는 샤드 클러스터에 데이터를 적절하게 분산 처리하기 위해 백그라운드 밸런스 작업을 수행한다. 특정 샤드가 지나치게 많은 데이터를 갖고 있다면 자동으로 데이터를 분산시켜준다. 밸런서는 필연적으로 데이터 생성 삭제를 수행하는데, 인덱스 때문에 성능이 떨어질 수 있다.

샤드1의 데이터를 샤드2로 옮길 때, 도큐먼트가 삭제되고 생성된다. 샤드1의 데이터가 삭제되었으므로 해당 인덱스를 삭제해야 하고 샤드2에는 해당 인덱스를 추가해야 한다. 이때 인덱스 트리를 매번 다시 구성해야 하므로 많은 오버헤드가 발생할 수 있다. 인덱스가 불필요하게 많은 컬렉션은 더욱더 데이터 밸런싱 작업을 지연시키고 부하를 일으키는 원인이 된다.

## Embedded-Document 인덱스

일반적으로 필드명은 인덱스 키 엔트리에 저장되지 않지만 임베디드 도큐먼트는 필드명이 같이 저장된다.

### 일반 인덱스
```js
interns = {
        nickname: "이름"
        ...
    }
db.interns.createIndex({ nickname: 1 })
```

```
index key  | value
-----------------------
andole     | a913df
-----------------------
buddy      | 9871bc
-----------------------
conny      | a89ce3
-----------------------
ehem       | 1653be
```

### Embedded Document 인덱스

```js
interns = {
    personal: {
        nickname: "이름",
        team: "팀",
        project: "프로젝트",
        ...
    }
    ...
}
db.interns.createIndex({ personal: 1 })
```

```
index key           | value
---------------------------------
nickname=andole     | 12345
---------------------------------
team=핀테크개발        | 31231
---------------------------------
project=제로페이시각화  | 17812
```

따라서 임베디드 도큐먼트의 인덱스 필드명은 짧은게 절대적으로 유리하다.

## 인덱스 키 사이즈

디스크에 데이터를 저장하는 가장 기본 단위를 페이지나 블록이라고 한다. 디스크 IO 작업의 최소 단위다. 운영체제는 모든 데이터를 페이지로 관리한다. 인덱스 역시 페이지 단위로 관리한다. 한 페이지에 인덱스가 많을 경우 찾아야 할 페이지의 숫자가 줄어든다. 한 페이지에 인덱스가 적을 경우 찾아야 할 페이지의 숫자가 커진다. 찾아야 할 페이지가 많을수록 디스크 IO이 많아진다. 결과적으로 성능에 좋지 않다.

인덱스의 자료구조에는 B-Tree가 많이 사용된다. 인덱스 크기에 따라 트리의 노드 갯수가 결정된다. 같은 데이터라도 인덱스 크기에 따라 B-Tree의 깊이가 달라진다. 깊이가 깊어질수록 리프 노드까지 읽어야 할 페이지 숫자가 글로벌하게 늘어난다. 인덱스 크기를 가능한 작게 설정하는게 유리하다.

페이지 크기를 16KB로 사용하고, 주소가 12byte인 경우

|         	| Index size 	| Index per Page 	| 16KB / Index size + Address Pointer size 	|
|:-------:	|:----------:	|:--------------:	|:----------------------------------------:	|
| A index 	|   4 byte   	|      1024      	|           16 * 1024 / (4 + 12)           	|
| B index 	|   12 byte  	|       682      	|           16 * 1024 / (12 + 12)          	|

인덱스 스캔 대상이 700개인 경우, A인덱스는 하나의 페이지만 읽어오면 되지만 B인덱스는 두개의 페이지를 읽어야 한다.

