---
title: "TDD 해보니"
category: Think
---

우아한테크코스는 [TDD](https://www.slideshare.net/javajigi/tdd-84038026) 전도사 박재성(a.k.a 자바지기)님께서 이끌고 있다. 코스 동안 TDD, ATDD가 주요 요구사항이었다. 8개월간 TDD를 연습하고 느낀 점을 적어본다.

## 선 테스트 작성의 의미

> 도대체 무슨 말인가. 뭐가 돌아가는게 있어야 테스트를 하지.

혼란스럽다. 테스트의 목적은 프로덕션 코드의 검증이 아닌가? 아무것도 없는, 검증할게 없는 상태에서 왜 테스트를 작성할까.  
테스트는 프로덕션 코드의 설명이기도 하다. 로직이 어떤 값을 받았을 때 어떤 결과가 나오는지 설명한다. 자연스러운 테스트의 속성이다.  

테스트를 먼저 작성하라는 것은, 테스트 대상에게 **바라는 것** 을 먼저 결정하라는 뜻이다.

이것은 많은 효과를 주는데, 객체지향적 설계에 도움을 준다. 도메인 레이어에서 대상 도메인이 무슨 **역할** 을 해야 하는지 생각하게 한다.  
나의 경우, 테스트 없이 객체를 설계할 때 필드부터 생각하는 경향이 있었다. 모델링은 필드 구성이라고 생각했었다. Book을 설계하려면 제목, 저자, 가격, ISBN ... 부터 생각했었다. 이것은 데이터 중심적 설계로, 빈약한 도메인이 되기 쉽다. 그러면서 로직은 서비스나 컨트롤러로 옮겨간다. 재사용성, 캡슐화가 깨지며 중복 로직이 다수 발생한다.

테스트를 통과하려면 도메인에 로직이 구현되어야 한다. 해당 도메인은 시스템에서 고유한 기능을 갖게 되고 다른 레이어에서 기능을 사용할 수 있게 한다. 중복을 제거하고 변경의 영향이 최소화된다.

## 어떻게 테스트할 것인가?

### private 메서드도 테스트해야 하나요?

네니요. 처음 TDD를 시작하면 이와 같은 생각을 하는 것 같다.  
테스트의 목적은 테스트 커버리지를 높이기 위한 것이 아니다. 대상 객체가 의도대로 행동하는지 확인하기 위한 것이다. 다시 말하면 대상 객체가 어떤 메시지를 받았을 때 어떻게 행동하는지 확인하는 것이다. 그러므로 대상 객체의 내부가 아닌, 외부 관점에서 테스트를 작성한다. 내부 필드가 어떤 **상태** 인지 알고 싶은게 아니다.  

`private` 는 대상 객체가 외부에 노출하고 싶지 않은 멤버다. 외부 입장에서는 모르는 것을 위임할 수 없는 노릇. 당연히 테스트 대상이 아니다.  

그럼 `private`는 테스트와 무관하냐 물으면 그건 아니다. 대상 객체는, 스스로의 메서드를 조합하여 요청에 응답한다. `public`으로 오픈한 메서드가 내부적으로는 `private` 메서드의 조합으로 이루어져 있을 수 있다. 객체 스스로도 책임을 분할하여 메시지를 전달할 수 있으며, 이건 OOP 캡슐화와 연관이 있다.  

다시말하면 `private`는 직접적인 테스트 대상이 아니나, `public`을 테스트하면 간접적으로 테스트된다.

간단한 계산기를 보자.

{% gist andole98/8b9259db5e8ff2477c8f8eae667de696 %}

안좋은 코드긴 한데... 위에서 아래로 구현했다. Calculator는 "1 + 2"를 계산하는 역할을 수행한다. "1 + 2"를 제대로 계산하는게 궁금하지, 문자열을 제대로 분리하는지 연산자를 제대로 체크하는지 궁금하지 않다. Calculator가 자율적으로 수행할 수 있는 부분이다. 그럼에도 `private` 는 `calculate`를 통해서 호출되므로, 테스트가 수행된다고 볼 수 있다. 

왜 `private`를 테스트해야 한다고 생각하나? 초보자들은 split이 제대로 되는지, `==`를 써야 할지 `equals`를 써야 할지 잘 모르기 때문이다. 언어의 기능이나 라이브러리를 익히고 싶다면, 학습 테스트를 추천한다. 토비의 스프링에서도 추천하는 부분이다.

{% gist andole98/e14e582edb08a8fba4dd99380d62fefe %}

### 이건 어떻게 테스트하죠?

테스트하기 어려운 코드가 있다. 해당 로직이 외부에 의존하는 경우가 대부분이다.  
랜덤 값에 따라 로직이 바뀜. 데이터베이스 상태에 따라 로직이 바뀜. 사용자 입력에 따라 로직이 바뀜.  

외부에 의존하는 부분을 분리해야 한다. 랜덤 값에 따라 로직이 바뀌는 코드라면, 랜덤 값을 생성하는 부분과 값에 따라 로직을 수행하는 부분을 분리해야 한다. 로직을 수행하는 부분에 임의의 값을 넣으면 테스트가 가능하다. 비즈니스 로직은 테스트가 가능해졌다. 테스트가 어려운 곳은 랜덤 값 생성 부분으로 국한된다.  

데이터베이스, 입력값 등도 마찬가지다. 데이터베이스에서 이런 값이 왔다고 **가정** 하고 로직을 구현할 수 있어야 한다. 대상 객체 내부에서 데이터베이스에 직접 접근하지 않고, 데이터베이스 접근 로직을 분리하면 된다. 여전히 데이터베이스는 테스트하기 어렵지만 비즈니스 로직은 얼마든지 테스트할 수 있다.  

### 좋은 테스트란 무엇인가?

아직도 잘 모르겠다. 다만 지금까지 느낀 바로는 상태를 검증하려 하면 좋지 않은 것 같다. VO라면 나름대로 검증하는게 좋고 쉽지만 엔터티라면 별로 좋지 않은 것 같다. 엔터티는 상태를 갖고 있으며 자주 변한다. 엔터티 상태를 정확히 체크하려 하면 지나치게 옥죄는 느낌이다. 향후 리팩토링을 진행할 때 getter로 테스트한 로직들이 깨지는 경우도 많았다. 엔터티는 상태를 직접 체크하려 하지 말고 간접 체크하는게 좋다고 느꼈다. 예컨대 상태를 VO로 관리해서 리턴하게 한다던지, 대상 엔터티가 판별 메서드를 제공한다든지... 이런 방식이 좀더 확장성 있고 유연한 것 같다.  
써놓고 보니 테스트 이야기가 아니라 도메인 이야기인데... 

여튼 좋은 테스트란 무엇인가? 에 대한 명확한 기준은 갖고 있지 않다. 가독성이 좋은 테스트, 동작을 잘 설명하는 테스트, 대상 객체에 자율을 주는 테스트... 당연히 좋다고 생각하지만 그 판단 기준이 명확하진 않다.ㅠㅠ

## 리팩토링의 의미

> TDD의 핵심 목적. 단순 테스트 통과가 아니라 좋은 설계가 될 때까지 리팩토링해야 한다. 

개인적으로 테스트의 존재 이유를 하나만 뽑으라면 리팩토링이라고 생각한다. 테스트를 작성해 두었기 때문에 바르게 동작하지 않음을 즉시 알수 있다. 이 말은 테스트 대상을 마음껏 변경해도 된다는 뜻이다. 변경하고 나서 잘 되었는지는 스스로 판단할 필요가 없다. 테스트가 판단한다.  

테스트를 작성한다. 주요 로직을 하드코딩해서 테스트를 통과했다. 테스트는 그대로 두고 하드코딩을 적절한 변수로 바꾸었다. 테스트를 돌려본다. 테스트가 통과한다. 해당 객체를 분리하고 싶어졌다. 내부적으로는 여러 객체들과 로직을 수행하게 리팩토링한다. 테스트를 돌려본다. 통과한다.

테스트를 통과하는 한, 자유롭게 설계를 바꿀 수 있다. 어디선가 본 디자인 패턴을 적용해 볼 수도 있다. 구현하면서 반복되는 로직을 통합하여 계층구조로 만들 수도 있다. 특정 로직을 병렬처리로 바꿔볼 수도 있다. 처음 작성해둔 테스트는 이 모든 것에 대해서 빠른 피드백을 준다.

## 어떻게 리팩토링할 것인가?

어느 정도 시스템이 갖춰진 뒤 리팩토링하면 기존 테스트가 발목을 잡을 때가 종종 있다. 테스트가 실패하는게 아니라 컴파일 에러가 나는 경우다. 컴파일이 안되면 테스트가 실행되지 않으므로 피드백을 받을 수가 없다. 테스트를 돌리기 위해 오랜 시간 컴파일 에러를 고쳐야 한다면 테스트에 대한 혐오가 생기기까지한다.

자바는 정적 타입 언어이므로 메서드 리턴 타입을 바꾸면 컴파일이 안된다. 그래도 이건 쉽게 처리할 수 있는 케이스다. 내 경우 가장 까다로웠던 것은 필드 변경이었다. 필드가 바뀌면 생성자 호출에서부터 컴파일 에러가 주르륵 발생한다. 테스트 대상 객체가 User처럼 시스템 전반에서 쓰이는 경우 거의 모든 테스트가 컴파일 에러를 뿜는다.

점진적 리팩토링이 필요하다. 대상 객체를 즉시 바꾸는게 아니라, 대상 객체는 그대로 둔다. 대신에 대상 객체의 리팩토링할 부분을 제 3의 영역에 준비한다. User를 바꾼다면 User2같은 임시 객체를 만드는 것이다. 단순히 User2만 추가되었으므로 컴파일 에러는 발생하지 않는다. User2는 자유롭게 새로운 설계를 반영하여 구현할 수 있다. 물론 TDD로 한다. 그 다음 User와 연관관계가 있는 객체들을 User2로 갈아끼운다. User가 더 이상 사용되는 곳이 없어지면 User를 지운다. User2는 User로 이름을 바꾼다. 이 동안 컴파일 에러는 User2를 갈아끼우는 곳에서 지역적으로 발생한다. 집중하고 있는 부분이므로 금방 해결할 수 있고, 시스템 전체로 퍼져나가지 않는다.

점진적 리팩토링에 대한 여러 기법과 스킬들이 있다. 내 생각에 점진적 리팩토링의 핵심 키워드는 Indirect다. 간접 참조로 두 상태, 레거시와 신규 오브젝트를 공존하게 하는 것이다. 어댑터가 그렇고 추상클래스가 그렇고 위 예시도 그렇다.

점진적 리팩토링에서 주의할 점은 팀과 기간이다. **레거시와 신규 오브젝트가 공존한다** 는 것은 달리 말하면 혼란하고 복잡한 상태라는 것을 의미한다. 만약 한달 동안 리팩토링한다고 생각해보자. 그동안 시스템 안에는 User, User2가 공존하고 있다. User를 리팩토링하는 당신에게는 좋은 방법일지 모르겠으나, 다른 업무를 하는 동료들은 죽을맛이다. User가 있고 User2가 또 있네? 뭐야? 사용자에 따라 새로운 기능을 개발해야 하는데 어떻게 하나? 한달 동안 동료에게 민폐를 주는 것이다.  
이런 경우는 겪어보진 않아서 뭐라 말하긴 어렵다. 곰곰 생각해보면 공존하는 시간을 최대한 짧게 두거나, 그것마저 어렵다면 아예 다른 환경에서 재구성하는 방법이 있겠다 싶다. 그래도 제일 중요한건 팀 차원의 합의와 공유이다.

## TDD는 생산성이 나쁘지 않나요?

처음에는 그렇다. 익숙해지면 도메인 레이어 한정으로 큰 차이가 없는 것 같다.  

일종의 반항으로 TDD하지 않았던 때가 있었다. 테스트가 없을 순 없으니 구현을 하고 나서 테스트를 작성했었다. 전체적으로 설계와 코드의 품질이 떨어졌다(도긴개긴이긴 하다). 구현과 테스트의 시간차가 발생하다 보니 테스트를 어중간하게 작성하거나, 성의있게 작성하지 못했다. 이 코드는 왜 있는 거지? 왜 이렇게 했지? 스스로에게 자꾸 의문이 들었다. 구현 중간에 불안함이 떠오르기도 했다. 이게 되나? 이게 맞아? 결국은 버그 찾느라고 디버깅에 시간을 쏟게 되었다.  

이런 싸이클을 타면 리팩토링에 보수적이게 된다. TDD할 때는 테스트 일단 만들어놓고 프로덕션을 **어떻게 바꿀까** 가 주요 관심사다. 그러므로 더 나은 설계, 더 나은 코드에 대한 욕심을 부릴 수 있다.  
구현을 먼저 하고 테스트를 할 때는 마인드가 달라진다. **구현한 대로** 테스트하려고 한다. 내가 구현한 것이 최고 최선이며, 그렇지 않더라도 어쩔 수 없어, 이제와서 바꿀 순 없잖아? 라고 생각하게 된다. 더 좋은 설계, 더 좋은 코드, 더 좋은 성장의 기회를 놓칠 수도 있다.  

구현을 먼저 하면 피로했다. 구현하면서 전체 그림을 항상 그리고 있어야 했다. 저게 저러니까 이건 이래야 돼 라는 생각을 머릿속에 담아두는 것과 테스트에 적어놓는 것은 천지차이다. 만약 천재라면 아무 영향이 없겠지만 나같이 머리 안좋은 애들은 머리에 쥐가 난다. 이거 하나만으로도 TDD는 꼭 배워야 한다.  

이미 개발 경험이 풍부한 실력자라면 TDD가 필요할까? 실력자는 테스트 없이도 높은 품질의 코드를 작성할 테니까 필요 없지 않나?  
내가 실력자라 아니라 잘 모르지만, 똑같은 이점이 있을 것 같다. 실력자라면 낮은 난이도의 코드를 작성할까? 오히려 복잡하고 어려운 코드를 작성할 때가 많을 것이고 TDD가 피로를 줄여줄 수 있을 것 같다. 

TDD가 생산성이 떨어진다고 하는 편견 아닌 편견은 익숙하지 않아서 나타나는 거라고 생각한다. 오히려 잘하시는 분들은 더 빠르기도 하다. 캡틴이 라이브코딩할 때 같은 공간안의 모든 사람이 넋이 나갔었던 걸 기억한다.   
캡틴의 라이브코딩을 보면서 느낀 것은, IDE를 잘 활용해야 한다는 것. 테스트 작성은 귀찮은 일이 되기 쉽다. 기능 자체에는 영향이 없는 코드를 타이핑해야 한다. 이런 반복 작업을 자바의 타입 시스템, IDE의 자동완성 기능으로 충분히 커버할 수 있다. IDE 테스트 관련 기능들에 익숙해져야 테스트 작성에 대한 거부감이 사라진다.  

어차피 할 테스트, 먼저 작성하는 것 뿐이다. 더해서 버그 찾느라 소모하는 디버깅 시간이 줄어든다. 매번 나은 코드를 작성하거나, 새로운 시도를 할 여유도 생긴다. 같은 테스트를 통과하는 코드는 여러개가 있을 수 있으므로.

다만 실력에 따라 편차가 클 것 같다. 리팩토링의 방향을 정확히 짚어내는 분들은 상당히 빠르게 사이클을 타실 수 있다. 경험이 부족하고 고민이 많을 때에는 시간이 오래 걸린다. 이것은 TDD의 문제라기 보다는 개인의 구현 능력차이라고 본다.  

## 소회

TDD를 하면서 자바에 정을 붙이게 된 것 같다. 전에는 생산성 낮고, 답답하고, 구식 언어의 느낌이 강했다. 테스트를 작성하면서 정적 타입 시스템이 주는 안정감, 객체지향 설계, 설계 & 리팩토링 기법은 다른 언어에서 느껴보지 못한 느낌이었다.  

지금은 다른 언어나 환경에서는 어떻게 TDD하거나 테스트하는지 궁금해 하고 있다. js의 제스트나 모카같은 프레임워크를 구경해보고 있다. 아무래도 정적 타입 시스템이 없다보니 약간은 불편해 보인다.  

지금의 허접한 실력이라도 혼자서 연습했다면 익힐수 있었을까, 아닌 것 같다. TDD는 고민거리나 경험적 노하우가 많고 진입장벽도 높은 편이라, 도움과 편의장치 없이는 지속적으로 연습하기 어려운 것 같다. 주변 동료들과 같이 좌절하고 고민하고 기뻐했기 때문에 계속해서 시도라도 할 수 있었던 것 같다.  

만약 TDD를 연습하거나 시도해 보고 싶으신 분이 있다면, 그 가치를 아는 다른 분과 함께 연습하시길 권하고 싶다. 혼자서는 지속하기 굉장히 어렵다. 기왕이면 페어 프로그래밍이 좋을 것 같다. 

TDD로 돈 벌어본 적은 없지만 아주 가치있다고 느낀다. 여러 걱정과 의심, 비난에도 TDD를 권해주신 캡틴 및 코치들께 감사할 뿐이다.
