---
published: true
layout: single
title: "자바스크립트 비동기 동작 원리"
category: TIL
comments: true
---
자바스크립트에서 비동기 처리(Non-blocking, Async 등)는 자주 언급되는 주제이다. 자바스크립트만 비동기로 동작할 수 있는 것은 아니다. 다른 언어들 모두 비동기로 동작하게 만들 수 있다. 그런데 왜 자바스크립트에서 많이 언급될까?   
js의 비동기 처리는 다른 언어들과 다른 원리로 동작한다. 이 때문에 쉽게 이용할 수 있으면서 제대로 이용하기 어렵다.  
대표적인 비동기 처리 메서드는 `setTimeout(callbackFn, delayTime)`일 것이다. `setTimeout`은 어떻게 실행되는지 알아보자.
```js
const testData = [1,2,3]
const asyncRun = function (arr, fn) {
    arr.forEach((v) => {
        console.log("sync " + v);
        setTimeout( () => {
            fn(v);
        },1000);
    })
}

asyncRun(testData, value => console.log("async " + value))
// 결과
sync 1
sync 2
sync 3
async 1
async 2
async 3
```
찬찬히 살펴보자. asyncRun 함수는 배열과 콜백을 인자로 받는다. 배열의 모든 요소를 출력하고, 콜백을 실행한다. 함수 호출에서 값을 출력하는 콜백을 전달했으므로 모든 배열의 값을 동기로 한번, 비동기로 한번 출력하게 된다.  
결과를 보면 분명 순서대로 한번씩 출력시켰으나 동기 출력이 먼저 실행되고 비동기 출력이 나중에 실행되는 것을 볼 수 있다. 이 콜백들은 어디에 있다가 난데없이 나타나서 실행되는 것일까? 콜스택에 보관해뒀다면 블러킹은 어떻게 하지? 자바스크립트는 싱글스레드라며?  
콜스택을 들여다보자.    


![callstack](/assets/IMG_3C29EC826F52-1.jpeg)  

주의깊게 볼 부분은 콜스택에서 `setTimeout`이 아무 일도 하지 않고 사라지는 것이다. `Sync`함수는 동작을 수행하고 스택에서 사라진다. `setTimeout`은 `Web API`에 `콜백`만을 전달하고 **스택에서 사라진다.**   
`Web API`에 등록된 콜백은, 타이머에 따라 언제 `실행준비`할지 정해진다. 예시에서는 1000ms였으므로 1초간 대기후, `실행할 준비`가 된다.  
그림의 아랫부분을 주의깊게 보면, 콜스택에서 `asyncRun`이 사라진 것을 볼 수 있다. 비동기로 실행이 준비된 함수들은, `콜스택에 아무것도 없을 때` 콜스택에 진입하여 실행된다.  
위와 같은 작동을 위해서 자바스크립트 실행환경에는 다음과 같은 장치들이 있다.

1. 콜스택
2. Web API(브라우저)
3. 콜백 큐
4. 이벤트 루프

그림으로 보자.  

![js re](/assets/1_FA9NGxNB6-v1oI2qGEtlRQ.png)

프로그래머의 코드는 무조건 콜스택에 올라간다. 동기 함수들은 콜스택 내에서 작업을 처리하고 소멸된다. 다른 언어들의 실행환경과 같다.  
그러나 비동기 함수들은, 바로 실행되지 않고 콜스택 외부에 콜백을 등록한다. `setTimeout`은 타이머에 등록되어 `콜백 큐`에 들어갈 준비를 한다. 타이머가 끝나면, 함수는 콜백 큐에 들어간다. `콜백 큐`는 이름에서 알 수 있듯이, 들어간 순서대로 빠져나올 수 있다. `콜스택`의 동작과는 다르게 먼저 들어온 함수가 우선권을 가진다.  
`이벤트 루프`는 콜스택을 주시하고 있다. 콜스택이 비어 있으면, `콜백 큐`의 함수를 콜스택에 올린다. 콜스택은 함수를 실행하고, 실행이 끝난 함수는 콜스택에서 사라진다. `이벤트 루프`는 콜스택이 비었음을 감지하고 큐에서 다음 함수를 꺼내 콜스택으로 이동시킨다.

그렇다. 자바스크립트는 태생이 브라우저 내에서 실행되는 것을 목표로 만들어졌기 때문에, 브라우저 의존적이다.  
다시말해 **브라우저를 이용할 수 있었다.** 프로그래머의 코드는 싱글스레드인 콜스택만을 이용할 수 있지만, 프로그래머는 브라우저 장치를 적절히 이용해서 코드를 실행할 수 있다. 당연하게도 `Web API`나 `콜백 큐`, `이벤트 루프`들은 브라우저가 운영체제로부터 얻어온 자원 내에서 돌아가는 쓰레드들이다. 

정리해보면, 자바스크립트의 비동기 함수의 동작 방식은 다음과 같다.
1. 비동기 처리 콜백 정보를 가진, 비동기 등록 함수(`setTimeout(callbackFn, second)`)가 콜스택에 올라간다.
2. 콜스택에서는 콜백을 실행하지 않고 `Web API`에 콜백을 등록한다. 그리고 소멸된다.  
2.1 콜스택은 소멸된 콜백은 무시하고 다음으로 넘어간다.  
2.2 `Web API`는 타이머에 콜백을 등록한다.
3. 타이머가 끝나면 콜백은 `콜백 큐`에 들어간다.
4. `이벤트 루프`는 콜스택이 비어 있으면, `콜백 큐`에서 하나씩 꺼내 콜스택에 올린다.
5. 비동기로 처리될 콜백은 이제서야 실행이 시작된다.

이런 구조를 파악하고 나니 자바스크립트에서 자주 쓰이는 이벤트 리스너의 작동원리도 유추가 가능했다. 이벤트 등록은 자바스크립트 콜스택 내부가 아닌 브라우저를 이용하는 것이다. 이벤트가 발생하면 등록된 콜백이 콜백 큐로 들어가고, 이벤트 루프가 콜스택이 비었을 때 콜스택에 올리고, 비로소 실행되는 것이다.  
자바스크립트의 불가사의했던 `window` 전역객체도, Node.js의 `global` 전역객체도 연관이 깊다. 이 전역객체는 따로 다룬다.

허접한 설명 말고 진짜를 원하신다면 다음 유튜브를 참고해 보시라.

[![youtube](https://img.youtube.com/vi/8aGhZQkoFbQ/0.jpg)](https://youtu.be/8aGhZQkoFbQ)